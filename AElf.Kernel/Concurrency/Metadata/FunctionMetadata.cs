using System;
using System.Collections.Generic;
using System.Linq;

// ReSharper disable once CheckNamespace
namespace AElf.Kernel
{
    /// <summary>
    /// The Metadata will not be changed after they are calculated as long as the related contracts don't update.
    /// Thus for each function, we store the whole set of metadata (which generated by accessing function's metadata recursively according to calling_set)
    /// When the contracts update, the metadata of related contracts' functions must be updated accordingly.
    /// </summary>
    public partial class FunctionMetadata
    {
        public FunctionMetadata(HashSet<string> callingSet, HashSet<Resource> fullResourceSet, HashSet<Resource> localResourceSet)
        {
            ContractContainsMetadata = true;
            SerializeCallingSet.AddRange(callingSet.AsEnumerable());
            SerializeFullResourceSet.AddRange(fullResourceSet.AsEnumerable());
            SerializeLocalResourceSet.AddRange(localResourceSet.AsEnumerable());
        }
        
        /// <summary>
        /// For contracts that contains no metadata
        /// </summary>
        /// <param name="nonMetadataContract">should always be false</param>
        public FunctionMetadata(bool nonMetadataContract)
        {
            ContractContainsMetadata = nonMetadataContract;
        }
        
        /// <summary>
        /// used to find influenced contract when a contract is updated
        /// </summary>
        public HashSet<string> CallingSet => new HashSet<string>(SerializeCallingSet);

        /// <summary>
        /// used to find what resource this function will access (recursive)
        /// </summary>
        public HashSet<Resource> FullResourceSet => new HashSet<Resource>(SerializeFullResourceSet);
        
        /// <summary>
        /// used when updating a function, the caller functions of this updating function should use this NonRecursivePathSet to regenerate the new metadata
        /// </summary>
        public HashSet<Resource> LocalResourceSet => new HashSet<Resource>(SerializeLocalResourceSet);
    }

    public partial class FunctionMetadataTemplate
    {
        public FunctionMetadataTemplate(HashSet<string> callingSet, HashSet<Resource> localResourceSet)
        {
            TemplateContainsMetadata = true;
            SerializeCallingSet.AddRange(callingSet.AsEnumerable());
            SerializeLocalResourceSet.Add(localResourceSet.AsEnumerable());
        }
        
        /// <summary>
        /// TODO: For the contracts that contains no metadata
        /// </summary>
        /// <param name="noMetadataTemplate"></param>
        public FunctionMetadataTemplate(bool noMetadataTemplate)
        {
            TemplateContainsMetadata = noMetadataTemplate;
        }

        //TODO: do we need to cache this hashset? or just new one whenever this getter is called
        public HashSet<string> CallingSet => new HashSet<string>(SerializeCallingSet);
        public HashSet<Resource> LocalResourceSet => new HashSet<Resource>(SerializeLocalResourceSet);
    }

    public partial class Resource
    {
        public Resource(string name, DataAccessMode dataAccessMode)
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            DataAccessMode = dataAccessMode;
        }
    }
}