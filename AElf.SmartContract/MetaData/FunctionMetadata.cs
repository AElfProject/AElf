using System;
using System.Collections.Generic;
using System.Linq;
using AElf.Kernel;
using AElf.SmartContract.MetaData;
using QuickGraph;
using QuickGraph.Algorithms;
using AElf.Common;

// ReSharper disable once CheckNamespace
namespace AElf.SmartContract
{
    /// <summary>
    /// The Metadata will not be changed after they are calculated as long as the related contracts don't update.
    /// Thus for each function, we store the whole set of metadata (which generated by accessing function's metadata recursively according to calling_set)
    /// When the contracts update, the metadata of related contracts' functions must be updated accordingly.
    /// </summary>
    public partial class FunctionMetadata
    {
        public FunctionMetadata(HashSet<string> callingSet, HashSet<Resource> fullResourceSet)
        {
            SerializeCallingSet.AddRange(callingSet.AsEnumerable());
            SerializeFullResourceSet.AddRange(fullResourceSet.AsEnumerable());
        }

        /// <summary>
        /// used to find influenced contract when a contract is updated
        /// </summary>
        public HashSet<string> CallingSet => new HashSet<string>(SerializeCallingSet);

        /// <summary>
        /// used to find what resource this function will access (recursive)
        /// </summary>
        public HashSet<Resource> FullResourceSet => new HashSet<Resource>(SerializeFullResourceSet);

        bool IEquatable<FunctionMetadata>.Equals(FunctionMetadata other)
        {
            return HashSet<string>.CreateSetComparer().Equals(CallingSet, other.CallingSet) &&
                   HashSet<Resource>.CreateSetComparer().Equals(FullResourceSet, other.FullResourceSet);
        }
    }
    
    public partial class Resource
    {
        public Resource(string name, DataAccessMode dataAccessMode)
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            DataAccessMode = dataAccessMode;
        }
    }

    public class FunctionMetadataTemplate : IEquatable<FunctionMetadataTemplate>
    {
        public readonly bool TemplateContainsMetadata;

        public FunctionMetadataTemplate(HashSet<string> callingSet, HashSet<Resource> localResourceSet)
        {
            TemplateContainsMetadata = true;
            CallingSet = callingSet;
            LocalResourceSet = localResourceSet;
        }

        /// <summary>
        /// TODO: For the contracts that contains no metadata
        /// </summary>
        /// <param name="noMetadataTemplate"></param>
        public FunctionMetadataTemplate(bool noMetadataTemplate)
        {
            TemplateContainsMetadata = false;
            LocalResourceSet = new HashSet<Resource>
            {
                new Resource("${this}._lock", DataAccessMode.ReadWriteAccountSharing)
            };
            CallingSet = new HashSet<string>();
        }

        public HashSet<string> CallingSet { get; }
        public HashSet<Resource> LocalResourceSet { get; }
        
        bool IEquatable<FunctionMetadataTemplate>.Equals(FunctionMetadataTemplate other)
        {
            return HashSet<string>.CreateSetComparer().Equals(CallingSet, other.CallingSet) &&
                   HashSet<Resource>.CreateSetComparer().Equals(LocalResourceSet, other.LocalResourceSet);
        }
    }

    public class ContractMetadataTemplate
    {
        public List<string> ProcessFunctionOrder;
        public CallGraph LocalCallingGraph;
        public Dictionary<string, FunctionMetadataTemplate> MethodMetadataTemplates;
        public string FullName;
        public Dictionary<string, Address> ContractReferences;
        public Dictionary<string, List<string>> ExternalFuncCall;

        
        public ContractMetadataTemplate(string fullName, Dictionary<string, FunctionMetadataTemplate> methodMetadataTemplates, Dictionary<string, Address> contractReferences)
        {
            FullName = fullName;
            MethodMetadataTemplates = methodMetadataTemplates;
            ContractReferences = contractReferences;
            
            ExternalFuncCall = new Dictionary<string, List<string>>();
            TrySetLocalCallingGraph(out var callGraph, out var topologicRes);
            ProcessFunctionOrder = topologicRes.Reverse().ToList();
            LocalCallingGraph = callGraph;
        }
        
        /// <summary>
        /// try to get
        /// (1) local calling graph, where only local function calls are considered
        /// (2) process function order ( reverse order of topological order of the calling graph)
        /// (3) external function call list for every function
        /// </summary>
        /// <param name="callGraph"></param>
        /// <param name="topologicRes"></param>
        private void TrySetLocalCallingGraph(out CallGraph callGraph, out IEnumerable<string> topologicRes)
        {
            callGraph = new CallGraph();
            foreach (var kvPair in MethodMetadataTemplates)
            {
                callGraph.AddVertex(kvPair.Key);
                foreach (var calledFunc in kvPair.Value.CallingSet)
                { 
                    if (calledFunc.StartsWith(Replacement.This))
                    {
                        callGraph.AddVerticesAndEdge(new Edge<string>(kvPair.Key, calledFunc));
                    }
                    else
                    {
                        if (!ExternalFuncCall.TryGetValue(kvPair.Key, out var callingList))
                        {
                            callingList = new List<string>();
                            ExternalFuncCall.Add(kvPair.Key, callingList);
                        }
                        callingList.Add(calledFunc);
                    }
                }
            }

            try
            {
                topologicRes = callGraph.TopologicalSort();
            }
            catch (NonAcyclicGraphException)
            {
                callGraph.Clear();
                callGraph = null;
                topologicRes = null;
                throw new FunctionMetadataException($"Calling graph of contract {FullName} is Non-DAG thus nothing take effect");
            }
        }
    }

    
}