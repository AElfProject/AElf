using System;
using System.Collections.Generic;
using System.Linq;
using AElf.CSharp.Core;
using AElf.Sdk.CSharp;
using AElf.Standards.ACS1;
using AElf.Standards.ACS10;
using AElf.Standards.ACS12;
using AElf.Types;
using Google.Protobuf;
using Google.Protobuf.Collections;
using Google.Protobuf.WellKnownTypes;

namespace AElf.Contracts.MultiToken;

public partial class TokenContract
{
    /// <summary>
    /// Related transactions will be generated by acs1 pre-plugin service,
    /// and will be executed before the origin transaction.
    /// </summary>
    /// <param name="input"></param>
    /// <returns></returns>
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }

    public override ChargeTransactionFeesOutput ChargeUserContractTransactionFees(ChargeTransactionFeesInput input)
    {
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var fee = new Dictionary<string, long>();
        var userContractMethodFees = GetActualFee(input.ContractAddress, input.MethodName);
        var isSizeFeeFree = false;
        if (userContractMethodFees != null)
        {
            isSizeFeeFree = userContractMethodFees.IsSizeFeeFree;
        }

        if (userContractMethodFees != null && userContractMethodFees.Fees.Any())
        {
            fee = GetUserContractFeeDictionary(userContractMethodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }

    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }

        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }

        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }

    private void AssertPermissionAndInput(ChargeTransactionFeesInput input)
    {
        AssertTransactionGeneratedByPlugin();
        Assert(input.MethodName != null && input.ContractAddress != null, "Invalid charge transaction fees input.");
    }

    private UserContractMethodFees GetActualFee(Address contractAddress, string methodName)
    {
        if (State.ConfigurationContract.Value == null)
            State.ConfigurationContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
        //Get the fee of the specified contract method set by the configuration contract.
        //configuration_key:UserContractMethod_contractAddress_methodName
        var spec = State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = $"{TokenContractConstants.UserContractMethodFeeKey}_{contractAddress}_{methodName}"
        });
        var fee = new UserContractMethodFees();
        if (!spec.Value.IsNullOrEmpty())
        {
            fee.MergeFrom(spec.Value);
            return fee;
        }

        //If special key is null,get the normal fee set by the configuration contract.
        //configuration_key:UserContractMethod
        var value = State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = TokenContractConstants.UserContractMethodFeeKey
        });
        if (value.Value.IsNullOrEmpty())
        {
            return new UserContractMethodFees();
        }

        fee.MergeFrom(value.Value);
        return fee;
    }

    private bool ChargeFromDelegations(ChargeTransactionFeesInput input, ref Address fromAddress,
        ref TransactionFeeBill bill, ref TransactionFreeFeeAllowanceBill allowanceBill,
        Dictionary<string, long> fee, bool isSizeFeeFree, Address delegatorAddress)
    {
        var chargingResult = false;
        // Try to charge delegatees
        // Get delegatee list according to the delegator
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;

        if (delegationInfo == null)
        {
            return false;
        }

        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;

            var delegateeBill = new TransactionFeeBill();
            var delegateeAllowanceBill = new TransactionFreeFeeAllowanceBill();
            var delegateeAddress = Address.FromBase58(delegatee);
            var delegateeChargingResult = ChargeTransactionFeesToBill(input, delegateeAddress,
                ref delegateeBill, ref delegateeAllowanceBill, fee, isSizeFeeFree, delegations);

            if (!delegateeChargingResult) continue;

            bill = delegateeBill;
            allowanceBill = delegateeAllowanceBill;
            fromAddress = delegateeAddress;
            chargingResult = true;
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }

            break;
        }

        return chargingResult;
    }

    private void ModifyDelegation(TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill,
        Address delegateeAddress, Address contractAddress, string methodName, Address delegatorAddress)
    {
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount <= 0) continue;

            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }
    }

    private void ModifyBalance(Address fromAddress, TransactionFeeBill bill,
        TransactionFreeFeeAllowanceBill allowanceBill)
    {
        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        // Update balances and allowances
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }

        if (freeAllowancesMap.Map == null || freeAllowancesMap.Map.Count == 0) return;

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount > 0)
            {
                ModifyFreeFeeAllowanceAmount(fromAddress, freeAllowancesMap, symbol, -amount);
            }
        }
    }

    private bool ChargeTransactionFeesToBill(ChargeTransactionFeesInput input, Address fromAddress,
        ref TransactionFeeBill bill,
        ref TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee, bool isSizeFeeFree = false,
        TransactionFeeDelegations delegations = null)
    {
        var successToChargeBaseFee = true;

        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }

        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
    }

    private void SetOrRefreshTransactionFeeFreeAllowances(Address address)
    {
        var config = State.TransactionFeeFreeAllowancesSymbolList.Value;
        if (config == null) return;

        foreach (var symbol in config.Symbols)
        {
            if (State.Balances[address][symbol] <
                State.TransactionFeeFreeAllowancesConfigMap[symbol].Threshold) continue;
            var lastRefreshTime = State.TransactionFeeFreeAllowancesLastRefreshTimes[address][symbol];

            if (lastRefreshTime != null && State.TransactionFeeFreeAllowancesConfigMap[symbol].RefreshSeconds >
                (Context.CurrentBlockTime - lastRefreshTime).Seconds) continue;

            State.TransactionFeeFreeAllowancesLastRefreshTimes[address][symbol] = Context.CurrentBlockTime;
            State.TransactionFeeFreeAllowances[address][symbol] =
                State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone();
        }
    }

    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }

    private Dictionary<string, long> GetUserContractFeeDictionary(UserContractMethodFees fees)
    {
        return fees.Fees
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }

    private bool ChargeBaseFee(Dictionary<string, long> methodFeeMap, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {
        Context.LogDebug(() => "ChargeBaseFee Start");
        // Fail to charge
        if (!ChargeFirstSufficientToken(methodFeeMap, fromAddress, out var symbolToChargeBaseFee,
                out var amountToChargeBaseFee, out var existingBalance, out var existingAllowance,
                transactionFeeFreeAllowancesMap,
                delegations))
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 

            return false;
        }

        // Succeed to charge, freeAllowance first.
        if (existingAllowance > amountToChargeBaseFee)
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee);
            // free fee allowance has covered fee, add 0 for size fee
            bill.FeesMap.Add(symbolToChargeBaseFee, 0);
        }
        else
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            bill.FeesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee.Sub(existingAllowance));
        }

        Context.LogDebug(() => "ChargeBaseFee End");
        return true;
    }

    private bool ChargeSizeFee(ChargeTransactionFeesInput input, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {

        Context.LogDebug(() => "ChargeSizeFee Start");

        //If delegation != null,from address->delegateeAddress
        // Size Fee is charged in primary token, elf.
        var symbolToPayTxFee = State.ChainPrimaryTokenSymbol.Value;
        //Get primary token balance
        GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
            out var symbolChargedForBaseFee, out var amountChargedForBaseFee, out var amountChargedForBaseAllowance,
            out var availableBalance, out var availableAllowance);
        var txSizeFeeAmount = input.TransactionSizeFee;

        // SymbolsToPayTxSizeFee is set of all available token can be charged, and with the ratio of primary token and another.
        if (input.SymbolsToPayTxSizeFee.Any())
        {
            var allSymbolToTxFee = input.SymbolsToPayTxSizeFee.ToList();
            var availableSymbol = GetAvailableSymbolToPayTxFee(allSymbolToTxFee, fromAddress, txSizeFeeAmount,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseFee,
                amountChargedForBaseAllowance, delegations);

            if (availableSymbol != null && availableSymbol.TokenSymbol != symbolToPayTxFee)
            {
                symbolToPayTxFee = availableSymbol.TokenSymbol;
                txSizeFeeAmount = txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight)
                    .Div(availableSymbol.BaseTokenWeight);
                GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
                    out symbolChargedForBaseFee, out amountChargedForBaseFee, out amountChargedForBaseAllowance,
                    out availableBalance, out availableAllowance);
            }

            //For delegation,if there is no available token,return false,no need to generate bill
            if (delegations != null && availableSymbol == null)
            {
                return false;
            }
        }

        var chargeResult = availableBalance.Add(availableAllowance) >= txSizeFeeAmount;
        if (delegations != null)
        {
            chargeResult = chargeResult && IsDelegationEnough(symbolToPayTxFee, symbolChargedForBaseFee,
                amountChargedForBaseFee.Add(amountChargedForBaseAllowance), txSizeFeeAmount, delegations);
            if (!chargeResult)
            {
                return false;
            }
        }

        GenerateBill(txSizeFeeAmount, symbolToPayTxFee, symbolChargedForBaseFee, availableBalance, availableAllowance,
            ref bill, ref allowanceBill);
        
        Context.LogDebug(() => "ChargeSizeFee End");

        return chargeResult;
    }

    private void GetAvailableBalance(string symbolToPayTxFee, Address fromAddress, TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, TransactionFreeFeeAllowanceBill allowanceBill,
        out string symbolChargedForBaseFee, out long amountChargedForBaseFee, out long amountChargedForBaseAllowance,
        out long availableBalance, out long availableAllowance)
    {
        symbolChargedForBaseFee = null;
        amountChargedForBaseFee = 0L;
        amountChargedForBaseAllowance = 0L;

        if (bill.FeesMap.Any())
        {
            symbolChargedForBaseFee = bill.FeesMap.First().Key;
            amountChargedForBaseFee = bill.FeesMap.First().Value;
            amountChargedForBaseAllowance = allowanceBill.FreeFeeAllowancesMap[symbolChargedForBaseFee];
        }

        availableBalance = symbolChargedForBaseFee == symbolToPayTxFee
            // Available balance need to deduct amountChargedForBaseFee, if base fee is charged in the same token.
            ? GetBalance(fromAddress, symbolToPayTxFee).Sub(amountChargedForBaseFee)
            : GetBalance(fromAddress, symbolToPayTxFee);
        availableAllowance = symbolChargedForBaseFee == symbolToPayTxFee
            ? GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbolToPayTxFee)
                .Sub(amountChargedForBaseAllowance)
            : GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbolToPayTxFee);
    }

    private SymbolToPayTxSizeFee GetAvailableSymbolToPayTxFee(List<SymbolToPayTxSizeFee> allSymbolToTxFee,
        Address fromAddress, long txSizeFeeAmount, TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        string symbolChargedForBaseFee, long amountChargedForBaseFee, long amountChargedForBaseAllowance,
        TransactionFeeDelegations delegations = null)
    {
        SymbolToPayTxSizeFee availableSymbol = null;
        SymbolToPayTxSizeFee availableSymbolWithAnything = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalance = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalancePlusAllowance = null;

        // get 1st Allowance > size fee, else, get 1st Balance + Allowance > 0, else get 1st > 0
        foreach (var symbolToPlayTxSizeFee in allSymbolToTxFee)
        {
            if (delegations != null)
            {
                var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                    symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
                    txSizeFeeAmount, delegations);
                if (!delegationEnough) break;
            }

            var allowance = GetAllowanceCalculatedBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseAllowance);
            var balance = GetBalanceCalculatedBaseOnPrimaryToken(fromAddress, symbolToPlayTxSizeFee,
                symbolChargedForBaseFee, amountChargedForBaseFee);
            
            var balancePlusAllowance = balance.Add(allowance);

            if (allowance >= txSizeFeeAmount)
            {
                availableSymbol = symbolToPlayTxSizeFee;
                break;
            }

            if (delegations == null && balancePlusAllowance > 0)
            {
                availableSymbolWithAnything ??= symbolToPlayTxSizeFee;
            }

            if (balancePlusAllowance < txSizeFeeAmount) continue;

            if (allowance > 0)
            {
                availableSymbolWithEnoughBalancePlusAllowance ??= symbolToPlayTxSizeFee;
            }
            else
            {
                availableSymbolWithEnoughBalance ??= symbolToPlayTxSizeFee;
            }
        }

        availableSymbol ??= availableSymbolWithEnoughBalancePlusAllowance ??
                            availableSymbolWithEnoughBalance ?? availableSymbolWithAnything;

        return availableSymbol;
    }

    private void GenerateBill(long txSizeFeeAmount, string symbolToPayTxFee, string symbolChargedForBaseFee,
        long availableBalance, long availableAllowance, ref TransactionFeeBill bill,
        ref TransactionFreeFeeAllowanceBill allowanceBill)
    {
        var chargeAmount = 0L;
        var chargeAllowanceAmount = 0L;
        if (availableBalance.Add(availableAllowance) > txSizeFeeAmount)
        {
            // Allowance > size fee, all allowance
            if (availableAllowance > txSizeFeeAmount)
            {
                chargeAllowanceAmount = txSizeFeeAmount;
            }
            else
            {
                // Allowance is not enough
                chargeAllowanceAmount = availableAllowance;
                chargeAmount = txSizeFeeAmount.Sub(chargeAllowanceAmount);
            }
        }
        else
        {
            chargeAllowanceAmount = availableAllowance;
            chargeAmount = availableBalance;
        }

        if (symbolChargedForBaseFee == symbolToPayTxFee)
        {
            bill.FeesMap[symbolToPayTxFee] =
                bill.FeesMap[symbolToPayTxFee].Add(chargeAmount);
            allowanceBill.FreeFeeAllowancesMap[symbolToPayTxFee] =
                allowanceBill.FreeFeeAllowancesMap[symbolToPayTxFee].Add(chargeAllowanceAmount);
        }
        else
        {
            if (chargeAmount > 0)
            {
                bill.FeesMap.Add(symbolToPayTxFee, chargeAmount);
            }

            if (chargeAllowanceAmount > 0)
            {
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToPayTxFee, chargeAllowanceAmount);
            }
        }
    }

    public override Empty ChargeResourceToken(ChargeResourceTokenInput input)
    {
        AssertTransactionGeneratedByPlugin();
        Context.LogDebug(() => $"Start executing ChargeResourceToken.{input}");
        if (input.Equals(new ChargeResourceTokenInput()))
        {
            return new Empty();
        }

        var bill = new TransactionFeeBill();
        foreach (var pair in input.CostDic)
        {
            Context.LogDebug(() => $"Charging {pair.Value} {pair.Key} tokens.");
            var existingBalance = GetBalance(Context.Sender, pair.Key);
            Assert(existingBalance >= pair.Value,
                $"Insufficient resource of {pair.Key}. Need balance: {pair.Value}; Current balance: {existingBalance}.");
            bill.FeesMap.Add(pair.Key, pair.Value);
        }

        foreach (var pair in bill.FeesMap)
        {
            Context.Fire(new ResourceTokenCharged
            {
                Symbol = pair.Key,
                Amount = pair.Value,
                ContractAddress = Context.Sender
            });
            if (pair.Value == 0)
            {
                Context.LogDebug(() => $"Maybe incorrect charged resource fee of {pair.Key}: it's 0.");
            }
        }

        return new Empty();
    }

    public override Empty CheckResourceToken(Empty input)
    {
        AssertTransactionGeneratedByPlugin();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayTxFeeSymbolListName))
        {
            var balance = GetBalance(Context.Sender, symbol);
            var owningBalance = State.OwningResourceToken[Context.Sender][symbol];
            Assert(balance > owningBalance,
                $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
        }

        return new Empty();
    }

    public override Empty SetSymbolsToPayTxSizeFee(SymbolListToPayTxSizeFee input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        if (input == null)
            throw new AssertionException("invalid input");
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        var primaryTokenInfo = State.TokenInfos[primaryTokenSymbol.Value];
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }

        Assert(isPrimaryTokenExist, $"primary token:{primaryTokenSymbol.Value} not included");
        State.SymbolListToPayTxSizeFee.Value = input;
        Context.Fire(new ExtraTokenListModified
        {
            SymbolListToPayTxSizeFee = input
        });
        return new Empty();
    }

    /// <summary>
    /// Example 1:
    /// symbolToAmountMap: {{"ELF", 10}, {"TSA", 1}, {"TSB", 2}}
    /// 
    /// [Charge successful]
    /// Sender's balance:
    /// ELF - 9
    /// TSA - 0
    /// TSB - 3
    /// Then charge 2 TSBs.
    /// 
    /// [Charge failed]
    /// Sender's balance:
    /// ELF - 9
    /// TSA - 0
    /// TSB - 1
    /// Then charge 9 ELFs
    /// 
    /// Example 2:
    /// symbolToAmountMap: {{"TSA", 1}, {"TSB", 2}}
    /// which means the charging token symbol list doesn't contain the native symbol.
    /// 
    /// [Charge successful]
    /// Sender's balance:
    /// ELF - 1
    /// TSA - 2
    /// TSB - 2
    /// Then charge 1 TSA
    /// 
    /// [Charge failed]
    /// Sender's balance:
    /// ELF - 1
    /// TSA - 0
    /// TSB - 1
    /// Then charge 1 TSB
    /// 
    /// [Charge failed]
    /// Sender's balance:
    /// ELF - 1000000000
    /// TSA - 0
    /// TSB - 0
    /// Then charge nothing.
    /// (Contract developer should be suggested to implement acs5 to check certain balance or allowance of sender.)
    /// </summary>
    /// <param name="symbolToAmountMap"></param>
    /// <param name="fromAddress"></param>
    /// <param name="symbol"></param>
    /// <param name="amount"></param>
    /// <param name="existingBalance"></param>
    /// <param name="existingAllowance"></param>
    /// <param name="transactionFeeFreeAllowancesMap"></param>
    /// <param name="delegations"></param>
    /// <returns></returns>
    private bool ChargeFirstSufficientToken(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        out string symbol, out long amount, out long existingBalance, out long existingAllowance,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, TransactionFeeDelegations delegations = null)
    {
        symbol = null;
        amount = 0L;
        existingBalance = 0L;
        existingAllowance = 0L;
        bool chargeResult;

        if (delegations != null)
        {
            //from address -> delegatee
            chargeResult = TryToChargeDelegateBaseFee(symbolToAmountMap, fromAddress, transactionFeeFreeAllowancesMap,
                delegations, out amount, out symbol, out existingBalance, out existingAllowance);
            return chargeResult;
        }

        chargeResult = TryToChargeUserBaseFee(symbolToAmountMap, fromAddress, transactionFeeFreeAllowancesMap,
            out amount, out symbol, out existingBalance, out existingAllowance);

        if (symbol != null)
        {
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
            amount = symbolToAmountMap[symbol];
        }

        //For user, if charge failed and delegation is null, priority charge primary token
        if (!chargeResult)
        {
            var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
            if (symbolToAmountMap.ContainsKey(primaryTokenSymbol))
            {
                symbol = primaryTokenSymbol;
                existingBalance = GetBalance(fromAddress, symbol);
                existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
            }
        }

        return chargeResult;
    }

    private bool TryToChargeUserBaseFee(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, out long amount,
        out string symbolOfValidBalance, out long existingBalance, out long existingAllowance)
    {
        // priority: enough allowance -> symbolWithEnoughBalancePlusAllowance -> symbolWithEnoughBalance -> symbolWithAnything
        symbolOfValidBalance = null;
        string symbolWithAnything = null;
        string symbolWithEnoughBalance = null;
        string symbolWithEnoughBalancePlusAllowance = null;

        amount = 0;
        existingBalance = 0;
        existingAllowance = 0;
        //For user
        //Find the token that satisfies the balance of the fee,if there is no token that satisfies the balance of the fee, find the token that balance > 0
        foreach (var (symbol, value) in symbolToAmountMap)
        {
            // current token symbol
            amount = value;
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);

            var existingBalancePlusAllowance = existingBalance.Add(existingAllowance);

            
            // allowance is enough to cover the base fee
            if (existingAllowance >= amount)
            {
                symbolOfValidBalance = symbol;
                return true;
            }

            if (existingBalancePlusAllowance <= 0) continue;
            
            // find symbol: balance + allowance > 0
            symbolWithAnything ??= symbol;

            if (existingBalancePlusAllowance < amount) continue;

            if (existingAllowance > 0)
            {
                // find symbol: balance plus allowance is enough to cover the base fee and allowance is greater than 0
                symbolWithEnoughBalancePlusAllowance ??= symbol;
            }
            else
            {
                // find symbol: balance is enough to cover the base fee and no allowance 
                symbolWithEnoughBalance ??= symbol;
            }
        }

        if (symbolWithEnoughBalancePlusAllowance == null && symbolWithEnoughBalance == null)
        {
            symbolOfValidBalance = symbolWithAnything;

            return false;
        }

        symbolOfValidBalance = symbolWithEnoughBalancePlusAllowance ?? symbolWithEnoughBalance;

        return true;
    }

    private bool TryToChargeDelegateBaseFee(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, TransactionFeeDelegations delegations,
        out long amount, out string symbolOfValidBalance, out long existingBalance, out long existingAllowance)
    {
        symbolOfValidBalance = null;
        amount = 0;
        existingBalance = 0;
        existingAllowance = 0;
        string symbolWithEnoughBalance = null;
        string symbolWithEnoughBalancePlusAllowance = null;

        //Find the token that satisfies the delegate limit and satisfies the balance of the fee
        foreach (var (symbol, value) in symbolToAmountMap)
        {
            // current token symbol
            amount = value;
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
            // is unlimited delegate is true || is unlimited delegate is false and delegation is enough
            if (delegations.IsUnlimitedDelegate || (!delegations.IsUnlimitedDelegate &&
                                                    delegations.Delegations.ContainsKey(symbol) &&
                                                    delegations.Delegations[symbol] >= amount))
            {
                //If allowance is enough,return true
                if (existingAllowance >= amount)
                {
                    symbolOfValidBalance = symbol;
                    return true;
                }

                //Find symbol which balance+allowance >= amount
                if (existingBalance.Add(existingAllowance) < amount) continue;

                if (existingAllowance > 0)
                {
                    //If balance+allowance is enough,priority find the symbol which allowance > 0
                    symbolWithEnoughBalancePlusAllowance ??= symbol;
                }
                else
                {
                    symbolWithEnoughBalance ??= symbol;
                }
            }
        }

        symbolOfValidBalance = symbolWithEnoughBalancePlusAllowance ?? symbolWithEnoughBalance;

        if (symbolOfValidBalance != null)
        {
            existingBalance = GetBalance(fromAddress, symbolOfValidBalance);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbolOfValidBalance);
            amount = symbolToAmountMap[symbolOfValidBalance];
        }
         
        return symbolOfValidBalance != null;
    }

    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }

    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }

    public override Hash GetLatestTotalTransactionFeesMapHash(Empty input)
    {
        return State.LatestTotalTransactionFeesMapHash.Value;
    }

    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
        if (State.DividendPoolContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            if (treasuryContractAddress == null)
            {
                isMainChain = false;
            }
            else
            {
                State.DividendPoolContract.Value = treasuryContractAddress;
            }
        }

        PayResourceTokens(input, isMainChain);

        if (!isMainChain)
        {
            PayRental();
        }

        return new Empty();
    }

    public override Hash GetLatestTotalResourceTokensMapsHash(Empty input)
    {
        return State.LatestTotalResourceTokensMapsHash.Value;
    }

    private void PayResourceTokens(TotalResourceTokensMaps billMaps, bool isMainChain)
    {
        foreach (var bill in billMaps.Value)
        {
            foreach (var feeMap in bill.TokensMap.Value)
            {
                var symbol = feeMap.Key;
                var amount = feeMap.Value;
                // Check balance in case of insufficient balance.
                var existingBalance = GetBalance(bill.ContractAddress, symbol);
                if (amount > existingBalance)
                {
                    var owned = amount.Sub(existingBalance);
                    var currentOwning = State.OwningResourceToken[bill.ContractAddress][symbol].Add(owned);
                    State.OwningResourceToken[bill.ContractAddress][symbol] = currentOwning;
                    Context.Fire(new ResourceTokenOwned
                    {
                        Symbol = symbol,
                        Amount = currentOwning,
                        ContractAddress = bill.ContractAddress
                    });
                    amount = existingBalance;
                }

                if (amount > 0)
                {
                    ModifyBalance(bill.ContractAddress, symbol, -amount);
                    var receiver = Context.Self;
                    if (isMainChain)
                    {
                        Context.LogDebug(() => $"Adding {amount} of {symbol}s to dividend pool.");
                        // Main Chain.
                        ModifyBalance(receiver, symbol, amount);
                        State.DividendPoolContract.Donate.Send(new DonateInput
                        {
                            Symbol = symbol,
                            Amount = amount
                        });
                    }
                    else
                    {
                        Context.LogDebug(() => $"Adding {amount} of {symbol}s to consensus address account.");
                        // Side Chain
                        receiver =
                            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
                        ModifyBalance(receiver, symbol, amount);
                    }
                    Context.Fire(new ResourceTokenClaimed
                    {
                        Symbol = symbol,
                        Amount = amount,
                        Payer = bill.ContractAddress,
                        Receiver = receiver
                    });
                }
            }
        }
    }

    private void PayRental()
    {
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
        if (State.LastPayRentTime.Value == null)
        {
            // Initial LastPayRentTime first calling DonateResourceToken.
            State.LastPayRentTime.Value = Context.CurrentBlockTime;
            return;
        }

        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }

    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }

    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }

    private void SetSideChainCreator(Address input)
    {
        Assert(State.SideChainCreator.Value == null, "Creator already set.");
        if (State.ParliamentContract.Value == null)
        {
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
        }

        Assert(Context.Sender == Context.GetZeroSmartContractAddress() ||
               Context.Sender == State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            "No permission.");
        State.SideChainCreator.Value = input;
    }

    /// <summary>
    /// Burn 10% of tx fees.
    /// If Side Chain didn't set FeeReceiver, burn all.
    /// </summary>
    /// <param name="symbol"></param>
    /// <param name="totalAmount"></param>
    private void TransferTransactionFeesToFeeReceiver(string symbol, long totalAmount)
    {
        Context.LogDebug(() => "Transfer transaction fee to receiver.");

        if (totalAmount <= 0) return;

        var tokenInfo = State.TokenInfos[symbol];
        if (!tokenInfo.IsBurnable)
        {
            return;
        }

        var burnAmount = totalAmount.Div(10);
        if (burnAmount > 0)
            Context.SendInline(Context.Self, nameof(Burn), new BurnInput
            {
                Symbol = symbol,
                Amount = burnAmount
            });

        var transferAmount = totalAmount.Sub(burnAmount);
        if (transferAmount == 0)
            return;
        var treasuryContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
        var isMainChain = treasuryContractAddress != null;
        if (isMainChain)
        {
            // Main chain would donate tx fees to dividend pool.
            if (State.DividendPoolContract.Value == null)
                State.DividendPoolContract.Value = treasuryContractAddress;
            State.Allowances[Context.Self][State.DividendPoolContract.Value][symbol] =
                State.Allowances[Context.Self][State.DividendPoolContract.Value][symbol].Add(transferAmount);
            State.DividendPoolContract.Donate.Send(new DonateInput
            {
                Symbol = symbol,
                Amount = transferAmount
            });
        }
        else
        {
            if (State.FeeReceiver.Value != null)
            {
                Context.SendInline(Context.Self, nameof(Transfer), new TransferInput
                {
                    To = State.FeeReceiver.Value,
                    Symbol = symbol,
                    Amount = transferAmount,
                });
            }
            else
            {
                // Burn all!
                Context.SendInline(Context.Self, nameof(Burn), new BurnInput
                {
                    Symbol = symbol,
                    Amount = transferAmount
                });
            }
        }
    }

    public override Empty SetFeeReceiver(Address input)
    {
        Assert(State.SideChainCreator.Value == Context.Sender, "No permission.");
        State.FeeReceiver.Value = input;
        return new Empty();
    }

    public override Address GetFeeReceiver(Empty input)
    {
        return State.FeeReceiver.Value;
    }

    public override Empty ConfigTransactionFeeFreeAllowances(ConfigTransactionFeeFreeAllowancesInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input.Value != null && input.Value.Count > 0, "Invalid input");

        State.TransactionFeeFreeAllowancesSymbolList.Value ??= new TransactionFeeFreeAllowancesSymbolList
        {
            Symbols = { new RepeatedField<string>() }
        };

        foreach (var allowances in input.Value!)
        {
            ValidateToken(allowances.Symbol);
            Assert(
                allowances.TransactionFeeFreeAllowances?.Value != null &&
                allowances.TransactionFeeFreeAllowances.Value.Count > 0,
                "Invalid input allowances");
            Assert(allowances.Threshold >= 0, "Invalid input threshold");
            Assert(allowances.RefreshSeconds >= 0, "Invalid input refresh seconds");

            var config = new TransactionFeeFreeAllowanceConfig
            {
                Symbol = allowances.Symbol,
                Threshold = allowances.Threshold,
                RefreshSeconds = allowances.RefreshSeconds,
                FreeAllowances = new TransactionFeeFreeAllowanceMap()
            };

            foreach (var allowance in allowances.TransactionFeeFreeAllowances!.Value!)
            {
                config.FreeAllowances.Map.TryAdd(allowance.Symbol, allowance);
            }

            State.TransactionFeeFreeAllowancesConfigMap[allowances.Symbol] = config;

            if (!State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Contains(allowances.Symbol))
            {
                State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Add(allowances.Symbol);
            }
        }

        return new Empty();
    }

    private void ValidateToken(string symbol)
    {
        Assert(!string.IsNullOrWhiteSpace(symbol), "Invalid input symbol");
        Assert(State.TokenInfos[symbol] != null, $"Symbol {symbol} not exist");
    }

    public override Empty RemoveTransactionFeeFreeAllowancesConfig(RemoveTransactionFeeFreeAllowancesConfigInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input.Symbols != null && input.Symbols.Count > 0, "Invalid input");
        Assert(State.TransactionFeeFreeAllowancesSymbolList.Value != null, "Method fee free allowances config not set");

        var symbols = input.Symbols!.Distinct();

        foreach (var symbol in symbols)
        {
            if (State.TransactionFeeFreeAllowancesSymbolList.Value!.Symbols.Contains(symbol))
            {
                State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Remove(symbol);
            }
        }

        return new Empty();
    }

    public override GetTransactionFeeFreeAllowancesConfigOutput GetTransactionFeeFreeAllowancesConfig(Empty input)
    {
        var symbols = State.TransactionFeeFreeAllowancesSymbolList.Value?.Symbols;
        if (symbols == null) return new GetTransactionFeeFreeAllowancesConfigOutput();
        
        var output = new GetTransactionFeeFreeAllowancesConfigOutput();

        foreach (var symbol in symbols)
        {
            output.Value.Add(State.TransactionFeeFreeAllowancesConfigMap[symbol]);
        }

        return output;
    }

    public override TransactionFeeFreeAllowancesMap GetTransactionFeeFreeAllowances(Address input)
    {
        return CalculateTransactionFeeFreeAllowances(input);
    }

    private TransactionFeeFreeAllowancesMap CalculateTransactionFeeFreeAllowances(Address input)
    {
        var freeAllowanceMap = State.TransactionFeeFreeAllowances[input];

        var freeAllowancesConfig = State.TransactionFeeFreeAllowancesSymbolList.Value;
        if (freeAllowancesConfig == null)
        {
            return new TransactionFeeFreeAllowancesMap();
        }

        var transactionFeeFreeAllowancesMap = new TransactionFeeFreeAllowancesMap();

        foreach (var symbol in freeAllowancesConfig.Symbols)
        {
            var balance = State.Balances[input][symbol];
            if (balance < State.TransactionFeeFreeAllowancesConfigMap[symbol].Threshold) continue;

            var lastRefreshTime = State.TransactionFeeFreeAllowancesLastRefreshTimes[input][symbol];

            var freeAllowances = freeAllowanceMap[symbol];

            if (freeAllowances == null)
            {
                transactionFeeFreeAllowancesMap.Map.Add(symbol,
                    State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone());
                continue;
            }

            if (lastRefreshTime == null)
            {
                transactionFeeFreeAllowancesMap.Map.Add(symbol, freeAllowances);
            }
            else
            {
                transactionFeeFreeAllowancesMap.Map[symbol] =
                    (Context.CurrentBlockTime - lastRefreshTime).Seconds >
                    State.TransactionFeeFreeAllowancesConfigMap[symbol].RefreshSeconds
                        ? State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone()
                        : freeAllowances;
            }
        }

        return transactionFeeFreeAllowancesMap;
    }

    private long GetBalanceCalculatedBaseOnPrimaryToken(Address fromAddress, SymbolToPayTxSizeFee tokenInfo,
        string baseSymbol,
        long cost)
    {
        var availableBalance = GetBalance(fromAddress, tokenInfo.TokenSymbol);
        if (tokenInfo.TokenSymbol == baseSymbol)
            availableBalance = availableBalance.Sub(cost);
        return availableBalance.Mul(tokenInfo.BaseTokenWeight)
            .Div(tokenInfo.AddedTokenWeight);
    }

    private long GetBalancePlusAllowanceCalculatedBaseOnPrimaryToken(Address fromAddress,
        SymbolToPayTxSizeFee tokenInfo, string baseSymbol,
        long cost, TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, long allowanceCost)
    {
        return GetBalanceCalculatedBaseOnPrimaryToken(fromAddress, tokenInfo, baseSymbol, cost).Add(
            GetAllowanceCalculatedBaseOnPrimaryToken(tokenInfo, transactionFeeFreeAllowancesMap, baseSymbol,
                allowanceCost));
    }

    private long GetAllowanceCalculatedBaseOnPrimaryToken(SymbolToPayTxSizeFee tokenInfo,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string baseSymbol,
        long allowanceCost)
    {
        var availableAllowance =
            GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap,
                tokenInfo.TokenSymbol); //GetBalance(Context.Sender, tokenInfo.TokenSymbol);
        if (tokenInfo.TokenSymbol == baseSymbol)
            availableAllowance = availableAllowance.Sub(allowanceCost);
        return availableAllowance.Mul(tokenInfo.BaseTokenWeight)
            .Div(tokenInfo.AddedTokenWeight);
    }

    private bool IsDelegationEnoughBaseOnPrimaryToken(SymbolToPayTxSizeFee tokenInfo, string baseSymbol, long cost,
        long txSizeFeeAmount, TransactionFeeDelegations delegations)
    {
        txSizeFeeAmount = txSizeFeeAmount.Mul(tokenInfo.AddedTokenWeight)
            .Div(tokenInfo.BaseTokenWeight);
        return IsDelegationEnough(tokenInfo.TokenSymbol, baseSymbol, cost, txSizeFeeAmount, delegations);
    }

    private bool IsDelegationEnough(string txSymbol, string baseSymbol, long cost,
        long txSizeFeeAmount, TransactionFeeDelegations delegations)
    {
        if (!delegations.IsUnlimitedDelegate)
        {
            return delegations.Delegations.ContainsKey(txSymbol) && (baseSymbol == txSymbol
                ? delegations.Delegations[txSymbol].Sub(cost)
                : delegations.Delegations[txSymbol]) >= txSizeFeeAmount;
        }

        return true;
    }

    private void AssertSymbolToPayTxFeeIsValid(string tokenSymbol, out long totalSupply)
    {
        var tokenInfo = State.TokenInfos[tokenSymbol];
        if (tokenInfo == null)
        {
            throw new AssertionException($"Token is not found. {tokenSymbol}");
        }

        Assert(IsTokenAvailableForMethodFee(tokenSymbol), $"Token {tokenSymbol} cannot set as method fee.");
        totalSupply = tokenInfo.TotalSupply;
    }

    private void AssertTransactionGeneratedByPlugin()
    {
        Assert(Context.TransactionId != Context.OriginTransactionId,
            "This method can only be executed in plugin tx.");
    }
}