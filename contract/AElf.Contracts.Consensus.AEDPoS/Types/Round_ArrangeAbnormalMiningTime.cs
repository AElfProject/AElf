using System;
using System.Linq;
using AElf.Sdk.CSharp;
using Google.Protobuf.WellKnownTypes;

namespace AElf.Contracts.Consensus.AEDPoS
{
    public partial class Round
    {
        /// <summary>
        /// If one node produced block this round or missed his time slot,
        /// whatever how long he missed, we can give him a consensus command with new time slot
        /// to produce a block (for terminating current round and start new round).
        /// The schedule generated by this command will be cancelled
        /// if this node executed blocks from other nodes.
        /// 
        /// Notice:
        /// This method shouldn't return the expected mining time from round information.
        /// To prevent this kind of misuse, this method will return a invalid timestamp
        /// when this node hasn't missed his time slot.
        /// </summary>
        /// <returns></returns>
        public Timestamp ArrangeAbnormalMiningTime(string publicKey, Timestamp dateTime,
            int miningInterval = 0)
        {
            if (!RealTimeMinersInformation.ContainsKey(publicKey))
            {
                return DateTime.MaxValue.ToUniversalTime().ToTimestamp();
            }

            if (miningInterval == 0)
            {
                miningInterval = GetMiningInterval();
            }

            var minerInRound = RealTimeMinersInformation[publicKey];
            if (!IsTimeSlotPassed(publicKey, dateTime) && minerInRound.OutValue == null)
            {
                return DateTime.MaxValue.ToUniversalTime().ToTimestamp();
            }

            if (GetExtraBlockProducerInformation().PublicKey == publicKey)
            {
                var distance = (GetExtraBlockMiningTime() - dateTime).Milliseconds();
                if (distance > 0)
                {
                    return GetExtraBlockMiningTime();
                }
            }

            if (RealTimeMinersInformation.ContainsKey(publicKey) && miningInterval > 0)
            {
                var distanceToRoundStartTime = (dateTime - GetStartTime()).Milliseconds();
                var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
                var expectedEndTime = GetExpectedEndTime(missedRoundsCount, miningInterval);
                return expectedEndTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
            }

            // Never do the mining if this node has no privilege to mime or the mining interval is invalid.
            return DateTime.MaxValue.ToUniversalTime().ToTimestamp();
        }

        private MinerInRound GetExtraBlockProducerInformation()
        {
            return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
        }

        /// <summary>
        /// This method for now is able to handle the situation of a miner keeping offline so many rounds,
        /// by using missedRoundsCount.
        /// </summary>
        /// <param name="miningInterval"></param>
        /// <param name="missedRoundsCount"></param>
        /// <returns></returns>
        private Timestamp GetExpectedEndTime(long missedRoundsCount = 0, int miningInterval = 0)
        {
            if (miningInterval == 0)
            {
                miningInterval = GetMiningInterval();
            }

            var totalMilliseconds = TotalMilliseconds(miningInterval);
            return GetStartTime().AddMilliseconds(totalMilliseconds)
                // Arrange an ending time if this node missed so many rounds.
                .AddMilliseconds(missedRoundsCount.Mul(totalMilliseconds));
        }

        /// <summary>
        /// In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
        /// produce a block to terminate current round and confirm the mining order of next round.
        /// So totally, the time of one round is:
        /// MiningInterval * MinersCount + MiningInterval.
        /// </summary>
        /// <param name="miningInterval"></param>
        /// <returns></returns>                                                
        private int TotalMilliseconds(int miningInterval = 0)
        {
            if (miningInterval == 0)
            {
                miningInterval = GetMiningInterval();
            }

            return RealTimeMinersInformation.Count * miningInterval + miningInterval;
        }
    }
}