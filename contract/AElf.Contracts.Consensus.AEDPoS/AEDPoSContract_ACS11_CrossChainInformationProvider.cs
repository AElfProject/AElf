using System.Linq;
using AElf.Contracts.MultiToken;
using AElf.CSharp.Core;
using AElf.Sdk.CSharp;
using AElf.Types;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;

namespace AElf.Contracts.Consensus.AEDPoS
{
    public partial class AEDPoSContract
    {
        #region UpdateConsensusInformation

        public override Empty UpdateInformationFromCrossChain(BytesValue input)
        {
            Assert(
                Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
                "Only Cross Chain Contract can call this method.");

            Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

            // For now we just extract the miner list from main chain consensus information, then update miners list.
            if (input == null || input.Value.IsEmpty) return new Empty();

            var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

            // check round number of shared consensus, not term number
            if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
                return new Empty();

            Context.LogDebug(() =>
                $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
                $"{consensusInformation.Round.ToString("M")}");

            DistributeResourceTokensToPreviousMiners();

            State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

            var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
            State.MainChainCurrentMinerList.Value = new MinerList
            {
                Pubkeys = {minersKeys.Select(ByteStringHelper.FromHexString)}
            };

            return new Empty();
        }

        private void DistributeResourceTokensToPreviousMiners()
        {
            if (State.TokenContract.Value == null)
            {
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
            }

            var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
            foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = symbol
                }).Balance;
                var amount = balance.Div(minerList.Count);
                Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
                if (amount <= 0) continue;
                foreach (var pubkey in minerList)
                {
                    var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                    Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                    State.TokenContract.Transfer.Send(new TransferInput
                    {
                        To = address,
                        Amount = amount,
                        Symbol = symbol
                    });
                }
            }
        }

        #endregion

        public override BytesValue GetChainInitializationInformation(BytesValue input)
        {
            return new BytesValue
            {
                Value = new MinerListWithRoundNumber
                {
                    MinerList = GetCurrentMinerList(new Empty()),
                    RoundNumber = State.CurrentRoundNumber.Value
                }.ToByteString()
            };
        }

        public override BoolValue CheckCrossChainIndexingPermission(Address input)
        {
            return IsCurrentMiner(input);
        }
    }
}