/**
 * NFT contract.
 */
syntax = "proto3";

package nft;

import "aelf/core.proto";
import "aelf/options.proto";
import "acs1.proto";
import "acs2.proto";
import "transaction_fee.proto";
import "authority_info.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";

option csharp_namespace = "AElf.Contracts.NFT";

service NFTContract {
    option (aelf.csharp_state) = "AElf.Contracts.NFT.NFTContractState";
    option (aelf.base) = "acs1.proto";
    option (aelf.base) = "acs2.proto";

    // Create a new nft type.
    rpc Create (CreateInput) returns (google.protobuf.Empty) {
    }
}

message NFTInfo {
    // The symbol of the token.f
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The current supply of the token.
    int64 supply = 3;
    // The total supply of the token.
    int64 total_supply = 4;
    // The address that created the token.
    aelf.Address issuer = 6;
    // A flag indicating if this token is burnable.
    bool is_burnable = 7;
    // The chain id of the token.
    int32 issue_chain_id = 8;
    // The amount of issued tokens.
    int64 issued = 9;
    // The external information of the token.
    ExternalInfo external_info = 10;
}

message CreateInput {
    // The symbol of the token.
    NFTType nft_type = 1;
    // The full name of the token.
    string token_name = 2;
    // The total supply of the token.
    int64 total_supply = 3;
    // The address that created the token.
    aelf.Address issuer = 5;
    // A flag indicating if this token is burnable.
    bool is_burnable = 6;
    // A whitelist address list used to lock tokens.
    repeated aelf.Address lock_white_list = 7;
    // The chain id of the token.
    int32 issue_chain_id = 8;
    // The external information of the token.
    ExternalInfo external_info = 9;
}

enum NFTType {
    ANY = 0;
    ART = 1;
    GAME = 2;
    CERT = 3;
    TICKET = 4;
}

message ExternalInfo {
    map<string, string> value = 1;
}

// Events

message NFTCreated {
    option (aelf.is_event) = true;
    // The symbol of the token.
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The total supply of the token.
    int64 total_supply = 3;
    // The address that created the token.
    aelf.Address issuer = 4;
    // A flag indicating if this token is burnable.
    bool is_burnable = 5;
    // The chain id of the token.
    int32 issue_chain_id = 6;
    // The external information of the token.
    ExternalInfo external_info = 7;
}