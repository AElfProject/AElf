# Blocks

## Overview

Blocks are generated by the Core Data Centers aka block producers or miners on schedule during their arranged time slots. In AElf blockchain, Core Data Centers have one or two time slots during one Round. The orders of their time slots for each Round is totally randomized. For every time slot, they can generate 1 to 8 blocks according to current running status of the AElf blockchain.

When the blocks generated, other nodes in the AElf blockchain network can syncing and validate blocks broadcast by Core Data Centers. When a valid block is double confirmed by more than two thirds of all current Core Data Centers, we can say this block is an irreversible block, and the block link (block height and block hash) will be treated as the Last Irreversible Block (LIB).

This section will introduce three aspects of blocks: structure, generation, and validation.

### Genesis Block

## Block Instance

The following message definitions show the structure of a Block and its constituents:

``` protobuf
message Block {
    BlockHeader header = 1;
    BlockBody body = 2;
}

message BlockHeader {
    int32 version = 1;
    int32 chain_id = 2;
    Hash previous_block_hash = 3;
    Hash merkle_tree_root_of_transactions = 4;
    Hash merkle_tree_root_of_world_state = 5;
    bytes bloom = 6;
    int64 height = 7;
    map<string, bytes> extra_data = 8;
    google.protobuf.Timestamp time = 9;
    Hash merkle_tree_root_of_transaction_status = 10;
    bytes signer_pubkey = 9999;
    bytes signature = 10000;
}

message BlockBody {
    repeated Hash transaction_ids = 1;
}

```

A block is the aggregation of a BlockHeader and a BlockBody.

### Block Header

The header contains metadata about the block itself. It also contains the the merkle roots of both the transactions and the world state.

### Block Header Extra Data

Currently we have three types of block header extra data:

- Cross Chain Extra Data. This is to record information come from cross chains thus support cross-chain interaction like cross-chain token transfer.
- Consensus Extra Data. This is to quickly validate whether a block is generated by a true Core Data Center and it is generated during right time slot of this Core Data Center.
- System Transaction Count. This is to support parallel execution. By knowing the count of system transactions, nodes can execute system transaction before executing parallizable transactions.

### Block Body

The block body is used to contain the transaction ids that where included in this block by the miner.

### Signature

The **signature** field is destined to host the signature of the producer of that block, to confirm that he created this block. It is the hash of the header that is signed, not the entire block.

### Merkel tree

The header contains the merkle tree of the transactions that where included in the block. It also contains the merkle tree of the state which is the merkle tree formed by the hash of the transaction ID and the status of its transaction result.

### Block Hash

A blockchain is also a data structure of cryptographically linked blocks. Inside the header there's the hash of the previous block. The hash of a block uniquely represents a block and become its identifier (sometimes called block id). This hash is based on multiple values, including the **chain id**, the **height** of the block in the chain, the previous **blocks hash** and **merkle roots** (but not only).

## Block Generation

### Stage 1: Instantiate a block before packaging transactions

Check following code in `BlockGenerationService.cs`:

```
public async Task<Block> GenerateBlockBeforeExecutionAsync(GenerateBlockDto generateBlockDto)
{
    var block = new Block
    {
        Header = new BlockHeader
        {
            ChainId = _staticChainInformationProvider.ChainId,
            Height = generateBlockDto.PreviousBlockHeight + 1,
            PreviousBlockHash = generateBlockDto.PreviousBlockHash,
            Time = generateBlockDto.BlockTime
        },
        Body = new BlockBody()
    };

    // get block extra data with _blockExtraDataService including consensus data, cross chain data etc.. 
    await _blockExtraDataService.FillBlockExtraDataAsync(block.Header);
    return block;
}
```

And the usage of above method:

```
/// <summary>
/// Generate block
/// </summary>
/// <returns></returns>
private async Task<Block> GenerateBlock(Hash preBlockHash, long preBlockHeight, Timestamp expectedMiningTime)
{
    var block = await _blockGenerationService.GenerateBlockBeforeExecutionAsync(new GenerateBlockDto
    {
        PreviousBlockHash = preBlockHash,
        PreviousBlockHeight = preBlockHeight,
        BlockTime = expectedMiningTime
    });
    block.Header.SignerPubkey = ByteString.CopyFrom(await _accountService.GetPublicKeyAsync());
    return block;
}
```

### Stage 2: Fetch executable transactions from the Transaction Pool

Every node in the AElf blockchain has to maintain a Transaction Pool to cache all the transaction received from network. After instantiating an empty block, Core Data Center can get normal executed transaction from his own Transaction Pool.

Check the code in `MinerService.cs`:

```
public async Task<BlockExecutedSet> MineAsync(Hash previousBlockHash, long previousBlockHeight, Timestamp blockTime,
    Duration blockExecutionTime)
{
    var limit = await _blockTransactionLimitProvider.GetLimitAsync(new ChainContext
    {
        BlockHash = previousBlockHash,
        BlockHeight = previousBlockHeight
    });
    var executableTransactionSet = await _transactionPoolService.GetExecutableTransactionSetAsync(previousBlockHash,
        _transactionPackingOptions.IsTransactionPackable
            ? limit
            : -1);

    Logger.LogDebug(
        $"Start mining with previous hash: {previousBlockHash}, previous height: {previousBlockHeight}.");
    return await _miningService.MineAsync(
        new RequestMiningDto
        {
            PreviousBlockHash = previousBlockHash,
            PreviousBlockHeight = previousBlockHeight,
            BlockExecutionTime = blockExecutionTime
        }, executableTransactionSet.Transactions, blockTime);
}
```

### Stage 3: Generate system transactions for new block

By iterating all the implementations of `ISystemTransactionGenerator`, the Core Data Center can generate several system transactions.

```
public class SystemTransactionGenerationService : ISystemTransactionGenerationService
{
    private readonly IEnumerable<ISystemTransactionGenerator> _systemTransactionGenerators;
    
    // ...

    public async Task<List<Transaction>> GenerateSystemTransactionsAsync(Address @from, long preBlockHeight,
        Hash preBlockHash)
    {
        var generatedTransactions = new List<Transaction>();
        foreach (var generator in _systemTransactionGenerators)
        {
            generatedTransactions.AddRange(
                await generator.GenerateTransactionsAsync(@from, preBlockHeight, preBlockHash));
        }

        return generatedTransactions;
    }
}
```

### Stage 4: Have all the transaction executed

Next, after collecting all the transaction potentially packaged into the new block, the implementations of `ITransactionExecutingService` interface will help to execute all the transaction by calling methods coded in the Smart Contract.

The execution result set and a signing will finally finished a block generation.

The total process can be very simply explained by following code:

```
var block = await GenerateBlock(requestMiningDto.PreviousBlockHash,
    requestMiningDto.PreviousBlockHeight, blockTime);
var systemTransactions = await GenerateSystemTransactions(requestMiningDto.PreviousBlockHash,
    requestMiningDto.PreviousBlockHeight);
var pending = transactions;
var blockExecutedSet = await _blockExecutingService.ExecuteBlockAsync(block.Header,
    systemTransactions, pending, cts.Token);

block = blockExecutedSet.Block;
await SignBlockAsync(block);
```

## Block Validation

Block validation mainly cares about two things:

- Is this block legal.
- Is this block produced by correct Core Data Center.

For the first thing, the legal means:

- Block Header and Block Body can't be null.
- The count of transactions included in this block can't be 0.
- Block can't contain duplicate transactions.
- Block can't contain transactions only can be generated by current Core Data Center.
- Block can't contain transactions only can be generated by transaction execution plugins.
- Block timestamp should be reasonable.
- ...

The second this will totally depends on the consensus mechanism, like in the AElf MainChain, it's AEDPoS. That's another story, you may check related contents in AEDPoS Contract design doc.
